 ===================================================Инструкция==========================================================
    Задание выполнено с использованием Spring boot+maven3.
    инструкция по развертыванию:
    1. сконфигурировать базу - подготовить пустую схему и пользователей(как минимум 1 пользователь должен обладать
    всеми привелегиями для заполнения схемы)

    2. скофигурировать настройку к базе данных. конфигурация находится в 2 файлах:
    -resources\application.properties
    -resources\db\liquibase.properties
    Это не ошибка, так и положено. Первая конфигурация предназначена для использования приложением при работе,
    вторая для построения схемы(требуется пользователь с большими привелегиями для выполнения DDL команд.
    Пользователи не обязаны совпадать)

    3. запустить чэнжлог с миграцией liquibase(в терминале написать mvn liquibase:update). после завершения должна быть
     создана база и внесены необходимые начальные данные

    4. Собрать проект с использованием Maven. Проект собирается как war. В проекте используются JSP, поэтому
    executable jar сделать не выйдет(точнее выйдет, но работать будет только Vaadin часть)
    4+. Лично я разворачиваю на локальном сервере tomcat через Intellij idea - так удобнее и намного быстрее:
    run->edit configuration. В появившемся окне добавляем новый Tomcat Server, выбираем local.
    В появившемся окне во вкладке deployment добавляем war, жмем ок. Все готово.

    5. развернуть war проекта (например под Tomcat)

    6.после развертывания проекта зайти на стартовую страницу (зависит от настроек сервера, под которым приложение
     развернули. Например localhost:8080)
     на стартовой странице 5 ссылок, ведущих к заказу:
     /order_webflow?lang=en
     /order_webflow?lang=ru
     /order_webmvc?lang=en
     /order_webmvc?lang=ru
     /order_vaadin
     Это сделано для удобства(быструй доступ).
     По завершении каждого заказа попадаем на страницу с информацией о заказе. Это опять же сделано для удобства,
     чтобы убедиться, что заказ сохранен в базу.


     7.В задании реализованы функциональные тесты на Selenium, поэтому также желательно установить и прописать пути
     к драйверам для запуска selenium тестов.

     дополнительно: для запуска как executable jar надо закомментить зависимость tomcat
     (ту, что под <!--Tomcat embedded container-->). Тогда приложение запустиься, но будет работать только Vaadin часть.

  ==================================================Описание===========================================================
  ==================================================Описание===========================================================
  ==================================================Описание===========================================================

  Задание выполнено в 3 экземплярах с использованием трех разных технологий(для целей обучения. Полезно знать плюсы и
  минусы каждой из них).
  1. Spring MVC
  2. Spring WebFlow
  3. Vaadin

  Поскольку задание тестовое, оно было немного усложнено(например реализован динамический перевод страниц в vaadin)

  что есть:
  -тесты (JUnit, Selenium)
  -layered architecture
  -liquibase
  -внешняя конфигурация
  -orm(hibernate)
  -валидация(JSR 303, custom)
  -валидация на стороне клиента(webflow, webmvc).
  -I18n интернационализация
  -кэширование данных там, где это целесообразно

  Теперь по порядку что есть:
  ==================================== Бэкенд:==========================================================================
  ==================================== Бэкенд:==========================================================================
  ==================================== Бэкенд:==========================================================================
  конфигурация соединения с базой данных в resources/application.properties
  Миграция написана в LiquiBase (resources/db/liquibase.properties)

  В бэкенде выделено 3 слоя: persistence, DAO, Service

  -Persistence сделано через Hibernate.
  Сущности лежат в папке entity. Также есть валидация JSR 303 всех сущностей перед сохранением в базу.

  -DAO лежат в папке repository.
  На этом уровне имеется кэш. Реализация кэша любезно предоставлена Spring boot по умолчанию.
  Кэшируются сорта кофе и параметры конфигурации, так как эти данные запрашиваются несколько раз за 1
  последовательность, и при этом фактически не меняются.

  -Сервисы лежат в папке service.
  Управление транзакциями происходит на этом уровне.

  Также здесьлежат:
   -файлы конфигурации Spring(configuration)
   -CoffeeOrderFinalValidator. Он применяется для валидации заказа непосредственно перед сохранением в базу данных.
   это необходимо всвязи с тем, что заказ пользователь вводит поэтапно(т. е. пользователь может выбрать кофе и пройти
    первый этап валидации утром, а адрес и подтверждение ввести вечером. За это время заказ может устареть,
    например один из сортов закончился - disabled='Y'. Чтобы не допустить невалидного заказа, нужна валидация заказа
    целиком перед сохранением)

    =================================Vaadin=============================================================================
    =================================Vaadin=============================================================================
    =================================Vaadin=============================================================================
    Компоненты лежат в папке vaadin, а также css в папке resources/VAADIN/themes/mytheme
    Ваадин позволяет добавить огромное количество фич, таких как:

    -реализован динамический перевод страницы(т. е. при смене языка просто меняются надписи, не изменяя состояния самой
        страницы. Можно выбрать 2 пункта на русском, затем переключить язык, и продолжить выбирать на английском, не потеряв
        данных)

    - реализовано динамическое отображение цены(пользователь видит как изменяется цена заказа во время построения)

    -все построено на слабо связанных компонентах, компоненты взаимодействуют только через интерфейсы путем создания
        событий. Например, чтобы поменять таблицу на грид картинок с кофе(или добавить кастомизации к кофе:
        большая/маленькая порция, в чашке/в стакане, с сахаром/без сахара и т. д.), нам надо реализовать всего лишь один
        интерфейс, не меняя больше ничего.

    -event driven технология. Позволяет вообще не раскрывать внутренних деталей компонента остальным компонентам.

    =============Компоненты и описание:

    International - функциональный интерфейс для интернационализации. Позволяет перевести компонент

    Navigable - функциональный интерфейс для организации последовательности. генерирует события перехода в
        последовательности

    CoffeeOrderBill-принимает счет для отображения пользователю

    CoffeeOrderManager-строит заказ и позволяет пользователю его редактировать.
        реализация суммирует одинаковые пункты заказа в один,
        позволяет удалить любой из имеющихся пунктов,
        отображает цену имеющегося заказа каждый раз при обновлении.

    CoffeeOrderItemSelector-пользователь взаимодействует с этим компонентом для создания пункта заказа. При создании
        пункта генерируется событие. Компонент с применением кастомного css(resources/VAADIN/themes/mytheme/custom.css).
        При большом количестве сортов кофе появится вертикальная полоса прокрутки.

    LocaleSelector-простой компонент для выбора языка(2 кнопки)

    CoffeeOrderItemsView-содержит CoffeeOrderManager и CoffeeOrderItemSelector. При нажатии кнопки заказа помещает
        пункты заказа из CoffeeOrderManager в сессию и генерирует событие.

    CoffeeOrderAddressView-достает из сессии пункты заказа, строит заказ, отображает стоимость заказа,
        принимает от пользователя имя и адрес. При нажатии кнопки подтверждения проводит последнюю валидацию заказа
        сохраняет его в базу данных и генерирует событие.

    ===============================================WebFlow==============================================================
    ===============================================WebFlow==============================================================
    ===============================================WebFlow==============================================================
    Классическая реализация через Spring WebFlow.

    =============Компоненты:
    CoffeeOrderWebflowController-сервис для работы последовательности, содержив все необходимые методы.

    WEB-INF\jsp - содержит JSP, дизайн такой же, как и в примере.

    WEB-INF\flows\coffee-flow.xml-описание последовательности.
    имеет 2 вида и несколько действий:

    coffee_list - стартовый вид. позволяет выбрать кофе.

    setItems - действие(решение). Забирает все параметры(так как число параметров и их названия изменяются,
    модель прикрутить не выйдет), далее парсит их, отбирая нужные, и вставляет их в модель заказа.

    calculate_cost - действие, считает цену заказа.

    address_input - вид, отображает цену и принимает имя и адрес в модель(nameAndAddress),
    а также проводит валидацию модели(JSR 303).

    fill_date_and_cost - действие. заполняет дату и цену.

    fill_name - действие. переносит имя из nameAndAddress в заказ

    fill_address - действие. переносит адрес из nameAndAddress в заказ

    validate_order - решение. проверка перед сохранением.

    save_order - действие. сохраняет заказ в базу.

    thank_user - ендпоин, вид. содержит ссылку на информацию о сделанном заказе.

    ======================================================Web MVC======================================================
    ======================================================Web MVC======================================================
    ======================================================Web MVC======================================================
    Реализация на MVC, асинхронное выполнение.
    Поскольку на javascript пишу первый раз, то решил его опробовать для разных вещей, в данном случае для получения
     данных с Rest сервиса.

    Компоненты:
    CoffeeListController - контроллер.
    get --- загружает в модель меню с сортами кофе для отодражения.
    post --- REST метод. принимает JSON тело, преобразует в Map<String, String>(синхронно)
        далее асинхронно конвертирует карту для получения пунктов заказа, попутно проводя валидацию.
        конвертация сделано внутри асинхронно вызываемого тела, так как для нее нужен доступ к блокирующим методам
        (хотя и есть кэш, вызовы всравно блокирующие). В зависимости от результатов конвертации:
        1... невозможно конвертировать(ошибка формата или сорта нет среди доступных) - BAD_REQUEST и
             сообщение ошибки в теле
        2... коныертация прошла успешно - помещает пункты заказа в сессию, статус=ACCEPTED, в теле ссылка для перехода
            на следующую страницу
        На стороне клиента с этим сервисом работает javascript функция, она же обрабатывает возвращаемый результат.
        В зависимости от статуса ответа либо показывает ошибку, либо перенаправляет на следующую страницу.

    AddressInputController - контроллер.
    get - достает пункты заказа из сессии, считает стоимость, и отображает пользователю счет.
    post - принимает имя и адрес, проводит синхронно их валидацию(JSR 303). Затем строит сам заказ и
        заполняет его данными. Потом проводит полную валидацию заказа перед сохранением:
        1...валидация не пройдена(данные устарели и уже не валтдны) - уничтожает сессию и отправляет на страницу ошибки.
        2...валидация пройдена - сохраняет заказ, помещает в сессию строку с идентификатором заказа, переадресуюет
            на следующую страницу.

    ThankUserController - контроллер.
    get - достает из сессии идентификатор заказа и строит ссылку на страницу с информацией о заказе.
            отображает пользователю благодарность и ссылку на страницу с информацией о заказе.

    OrderInfoController  - контроллер.
    get - принимает ид заказа как pathVariable, достает заказ из базы и отображает его пользователю.

    ===================================================Test============================================================

    JUnit тесты сервисов.
    небольшой JUnit тест на наличие кэша на одном из сервисов.
    Selenium тест webMVC(вводит заказ и проверяет правильность зарегистрироанного заказа)

    !!!
    На всякий случай: Selenium тест запускается не вместе со всеми тестами, а отдельно при развернутом приложении,
    так как он имитирует клиента и к серверу никакого отношения не имеет.
    Для запуска Selenium теста необходимо:
     1... скачать драйвер под свой браузер(у меня Opera).
     2... заменить мой путь на свой в классе SeleniumAbstract
        (public static final String OPERA_DRIVER="d:\\PROG\\Java\\install\\operadriver_win64\\operadriver.exe";)
        Зарегистрировать путь в конструкторе
        (System.setProperty("webdriver.opera.driver", OPERA_DRIVER);)
        создать драйвер под свой браузер в Before
        (driver=new OperaDriver();)

     3... указать свой URL к странице с WebMvc реализацией в классе SeleniumWebMvcTests
     (public static final String URL_WEBMVC="http://localhost:8080//order_webmvc";)

     4... запустить тест, и любоваться, как данные вводятся в открывшемся окне браузера=)










